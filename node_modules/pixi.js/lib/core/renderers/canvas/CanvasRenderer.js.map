{"version":3,"sources":["../../../../src/core/renderers/canvas/CanvasRenderer.js"],"names":["CanvasRenderer","screenWidth","screenHeight","options","type","CANVAS","rootContext","view","getContext","alpha","transparent","refresh","maskManager","smoothProperty","imageSmoothingEnabled","webkitImageSmoothingEnabled","mozImageSmoothingEnabled","oImageSmoothingEnabled","msImageSmoothingEnabled","initPlugins","blendModes","_activeBlendMode","context","renderingToScreen","resize","render","displayObject","renderTexture","clear","transform","skipUpdateTransform","emit","rootResolution","resolution","baseTexture","_canvasRenderTarget","width","height","source","canvas","valid","_lastObjectRendered","cacheParent","parent","tempWt","_tempDisplayObjectParent","worldTransform","copy","_worldID","identity","updateTransform","setTransform","globalAlpha","globalCompositeOperation","NORMAL","navigator","isCocoonJS","screencanvas","fillStyle","undefined","clearBeforeRender","clearRect","_backgroundColorString","fillRect","tempContext","renderCanvas","clearColor","setBlendMode","blendMode","destroy","removeView","destroyPlugins","SCALE_MODE","LINEAR","mixin"],"mappings":"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","file":"CanvasRenderer.js","sourcesContent":["import SystemRenderer from '../SystemRenderer';\nimport CanvasMaskManager from './utils/CanvasMaskManager';\nimport CanvasRenderTarget from './utils/CanvasRenderTarget';\nimport mapCanvasBlendModesToPixi from './utils/mapCanvasBlendModesToPixi';\nimport { pluginTarget } from '../../utils';\nimport { RENDERER_TYPE, SCALE_MODES, BLEND_MODES } from '../../const';\nimport settings from '../../settings';\n\n/**\n * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should\n * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to\n * your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\nexport default class CanvasRenderer extends SystemRenderer\n{\n    /**\n     * @param {number} [screenWidth=800] - the width of the screen\n     * @param {number} [screenHeight=600] - the height of the screen\n     * @param {object} [options] - The optional renderer parameters\n     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n     * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)\n     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The\n     *  resolution of the renderer retina would be 2.\n     * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear the canvas or\n     *      not before the new render pass.\n     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n     *  (shown if not transparent).\n     * @param {boolean} [options.roundPixels=false] - If true Pixi will Math.floor() x/y values when rendering,\n     *  stopping pixel interpolation.\n     */\n    constructor(screenWidth, screenHeight, options = {})\n    {\n        super('Canvas', screenWidth, screenHeight, options);\n\n        this.type = RENDERER_TYPE.CANVAS;\n\n        /**\n         * The canvas 2d context that everything is drawn with.\n         *\n         * @member {CanvasRenderingContext2D}\n         */\n        this.rootContext = this.view.getContext('2d', { alpha: this.transparent });\n\n        /**\n         * Boolean flag controlling canvas refresh.\n         *\n         * @member {boolean}\n         */\n        this.refresh = true;\n\n        /**\n         * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.\n         *\n         * @member {PIXI.CanvasMaskManager}\n         */\n        this.maskManager = new CanvasMaskManager(this);\n\n        /**\n         * The canvas property used to set the canvas smoothing property.\n         *\n         * @member {string}\n         */\n        this.smoothProperty = 'imageSmoothingEnabled';\n\n        if (!this.rootContext.imageSmoothingEnabled)\n        {\n            if (this.rootContext.webkitImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'webkitImageSmoothingEnabled';\n            }\n            else if (this.rootContext.mozImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'mozImageSmoothingEnabled';\n            }\n            else if (this.rootContext.oImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'oImageSmoothingEnabled';\n            }\n            else if (this.rootContext.msImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'msImageSmoothingEnabled';\n            }\n        }\n\n        this.initPlugins();\n\n        this.blendModes = mapCanvasBlendModesToPixi();\n        this._activeBlendMode = null;\n\n        this.context = null;\n        this.renderingToScreen = false;\n\n        this.resize(screenWidth, screenHeight);\n    }\n\n    /**\n     * Renders the object to this canvas view\n     *\n     * @param {PIXI.DisplayObject} displayObject - The object to be rendered\n     * @param {PIXI.RenderTexture} [renderTexture] - A render texture to be rendered to.\n     *  If unset, it will render to the root context.\n     * @param {boolean} [clear=false] - Whether to clear the canvas before drawing\n     * @param {PIXI.Transform} [transform] - A transformation to be applied\n     * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform\n     */\n    render(displayObject, renderTexture, clear, transform, skipUpdateTransform)\n    {\n        if (!this.view)\n        {\n            return;\n        }\n\n        // can be handy to know!\n        this.renderingToScreen = !renderTexture;\n\n        this.emit('prerender');\n\n        const rootResolution = this.resolution;\n\n        if (renderTexture)\n        {\n            renderTexture = renderTexture.baseTexture || renderTexture;\n\n            if (!renderTexture._canvasRenderTarget)\n            {\n                renderTexture._canvasRenderTarget = new CanvasRenderTarget(\n                    renderTexture.width,\n                    renderTexture.height,\n                    renderTexture.resolution\n                );\n                renderTexture.source = renderTexture._canvasRenderTarget.canvas;\n                renderTexture.valid = true;\n            }\n\n            this.context = renderTexture._canvasRenderTarget.context;\n            this.resolution = renderTexture._canvasRenderTarget.resolution;\n        }\n        else\n        {\n            this.context = this.rootContext;\n        }\n\n        const context = this.context;\n\n        if (!renderTexture)\n        {\n            this._lastObjectRendered = displayObject;\n        }\n\n        if (!skipUpdateTransform)\n        {\n            // update the scene graph\n            const cacheParent = displayObject.parent;\n            const tempWt = this._tempDisplayObjectParent.transform.worldTransform;\n\n            if (transform)\n            {\n                transform.copy(tempWt);\n\n                // lets not forget to flag the parent transform as dirty...\n                this._tempDisplayObjectParent.transform._worldID = -1;\n            }\n            else\n            {\n                tempWt.identity();\n            }\n\n            displayObject.parent = this._tempDisplayObjectParent;\n\n            displayObject.updateTransform();\n            displayObject.parent = cacheParent;\n            // displayObject.hitArea = //TODO add a temp hit area\n        }\n\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.globalAlpha = 1;\n        context.globalCompositeOperation = this.blendModes[BLEND_MODES.NORMAL];\n\n        if (navigator.isCocoonJS && this.view.screencanvas)\n        {\n            context.fillStyle = 'black';\n            context.clear();\n        }\n\n        if (clear !== undefined ? clear : this.clearBeforeRender)\n        {\n            if (this.renderingToScreen)\n            {\n                if (this.transparent)\n                {\n                    context.clearRect(0, 0, this.width, this.height);\n                }\n                else\n                {\n                    context.fillStyle = this._backgroundColorString;\n                    context.fillRect(0, 0, this.width, this.height);\n                }\n            } // else {\n            // TODO: implement background for CanvasRenderTarget or RenderTexture?\n            // }\n        }\n\n        // TODO RENDER TARGET STUFF HERE..\n        const tempContext = this.context;\n\n        this.context = context;\n        displayObject.renderCanvas(this);\n        this.context = tempContext;\n\n        this.resolution = rootResolution;\n\n        this.emit('postrender');\n    }\n\n    /**\n     * Clear the canvas of renderer.\n     *\n     * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.\n     */\n    clear(clearColor)\n    {\n        const context = this.context;\n\n        clearColor = clearColor || this._backgroundColorString;\n\n        if (!this.transparent && clearColor)\n        {\n            context.fillStyle = clearColor;\n            context.fillRect(0, 0, this.width, this.height);\n        }\n        else\n        {\n            context.clearRect(0, 0, this.width, this.height);\n        }\n    }\n\n    /**\n     * Sets the blend mode of the renderer.\n     *\n     * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.\n     */\n    setBlendMode(blendMode)\n    {\n        if (this._activeBlendMode === blendMode)\n        {\n            return;\n        }\n\n        this._activeBlendMode = blendMode;\n        this.context.globalCompositeOperation = this.blendModes[blendMode];\n    }\n\n    /**\n     * Removes everything from the renderer and optionally removes the Canvas DOM element.\n     *\n     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n     */\n    destroy(removeView)\n    {\n        this.destroyPlugins();\n\n        // call the base destroy\n        super.destroy(removeView);\n\n        this.context = null;\n\n        this.refresh = true;\n\n        this.maskManager.destroy();\n        this.maskManager = null;\n\n        this.smoothProperty = null;\n    }\n\n    /**\n     * Resizes the canvas view to the specified width and height.\n     *\n     * @extends PIXI.SystemRenderer#resize\n     *\n     * @param {number} screenWidth - the new width of the screen\n     * @param {number} screenHeight - the new height of the screen\n     */\n    resize(screenWidth, screenHeight)\n    {\n        super.resize(screenWidth, screenHeight);\n\n        // reset the scale mode.. oddly this seems to be reset when the canvas is resized.\n        // surely a browser bug?? Let pixi fix that for you..\n        if (this.smoothProperty)\n        {\n            this.rootContext[this.smoothProperty] = (settings.SCALE_MODE === SCALE_MODES.LINEAR);\n        }\n    }\n}\n\npluginTarget.mixin(CanvasRenderer);\n"]}